<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>ZKP-C Coloring – Web Visualizer</title>
    <style>
            @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;600;700&family=IBM+Plex+Mono:wght@400;600&display=swap');
        * {
            box-sizing: border-box;
        }
        :root {
            color-scheme: dark;
                font-family: "Space Grotesk", "DM Sans", "Segoe UI", system-ui, sans-serif;
                --bg-primary: #04070d;
                --bg-secondary: #0b111a;
                --bg-card: rgba(10, 14, 22, 0.95);
                --border: rgba(120, 132, 163, 0.22);
                --text-primary: #ecf0f8;
                --text-secondary: #8d96ad;
                --accent-blue: #6b89c6;
                --accent-green: #6ba68a;
                --accent-yellow: #d4b26a;
                --accent-red: #c5847c;
        }
        body {
            margin: 0;
            padding: 0;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow-x: hidden;
        }
        .container {
            max-width: 1920px;
            margin: 0 auto;
            padding: 20px;
            display: grid;
            grid-template-columns: 1fr 420px;
            grid-template-rows: auto 1fr;
            gap: 20px;
            min-height: 100vh;
        }
        .header {
            grid-column: 1 / -1;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 24px;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 12px;
            backdrop-filter: blur(10px);
        }
        .header h1 {
            margin: 0;
                font-size: 1.45rem;
                font-weight: 600;
                letter-spacing: 0.04em;
        }
        .status-badge {
            padding: 8px 16px;
            border-radius: 20px;
                background: rgba(107, 137, 198, 0.18);
                color: #c3d4ff;
            font-size: 0.875rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .main-content {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
        }
        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 20px;
            overflow-y: auto;
            max-height: calc(100vh - 120px);
        }
        .card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 14px;
            padding: 20px;
            backdrop-filter: blur(14px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
        }
        .card-title {
            font-size: 0.875rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-secondary);
            margin: 0 0 16px 0;
        }
        .graph-container {
            position: relative;
            background: var(--bg-secondary);
            border-radius: 16px;
            border: 1px solid var(--border);
            overflow: hidden;
            box-shadow: inset 0 0 50px rgba(0, 0, 0, 0.5);
        }
        #graph-canvas {
            width: 100%;
            height: auto;
            display: block;
        }
        .graph-caption {
            padding: 12px 20px;
            background: rgba(2, 6, 23, 0.8);
            color: var(--text-secondary);
            font-size: 0.875rem;
            border-top: 1px solid var(--border);
        }
        .info-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            font-size: 0.875rem;
        }
        .info-item {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        .info-label {
            color: var(--text-secondary);
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .info-value {
            color: var(--text-primary);
            font-weight: 600;
            font-family: "JetBrains Mono", monospace;
        }
        .protocol-steps {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .protocol-step {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 14px;
            border-radius: 10px;
            background: rgba(9, 14, 23, 0.7);
            border: 2px solid var(--border);
            transition: all 0.3s ease;
        }
        .protocol-step.active {
                background: rgba(107, 137, 198, 0.2);
                border-color: rgba(107, 137, 198, 0.7);
                box-shadow: 0 0 16px rgba(107, 137, 198, 0.25);
        }
        .protocol-step.completed {
                background: rgba(107, 166, 138, 0.18);
                border-color: rgba(107, 166, 138, 0.65);
        }
        .step-icon {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 0.875rem;
            background: rgba(141, 150, 173, 0.25);
            color: var(--text-secondary);
            flex-shrink: 0;
        }
        .protocol-step.active .step-icon {
            background: var(--accent-blue);
            color: white;
        }
        .protocol-step.completed .step-icon {
            background: var(--accent-green);
            color: white;
        }
        .step-content {
            flex: 1;
            min-width: 0;
        }
        .step-title {
            font-weight: 600;
            margin-bottom: 4px;
            font-size: 0.875rem;
        }
        .step-detail {
            font-size: 0.75rem;
            color: var(--text-secondary);
        }
        .link-button {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 12px 18px;
            border-radius: 10px;
            background: rgba(107, 137, 198, 0.12);
            border: 1px solid rgba(107, 137, 198, 0.4);
            color: #c3d4ff;
            font-weight: 600;
            text-decoration: none;
            transition: background 0.2s ease, border-color 0.2s ease;
        }
        .link-button:hover {
            background: rgba(107, 137, 198, 0.22);
            border-color: rgba(107, 137, 198, 0.6);
        }
        .control-bar {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        .control-bar button {
            flex: 1;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid var(--border);
            background: rgba(10, 14, 22, 0.8);
            color: var(--text-primary);
            cursor: pointer;
            font-size: 0.875rem;
            font-weight: 500;
            transition: all 0.2s;
        }
        .control-bar button:hover {
            background: rgba(107, 137, 198, 0.2);
            border-color: var(--accent-blue);
        }
        .control-bar button:active {
            transform: scale(0.98);
        }
        .logs-container {
            max-height: 300px;
            overflow-y: auto;
        }
        .logs {
            font-family: "IBM Plex Mono", "JetBrains Mono", monospace;
            font-size: 0.8125rem;
            line-height: 1.6;
            color: var(--text-secondary);
            white-space: pre-wrap;
            padding: 12px;
            background: rgba(2, 6, 23, 0.4);
            border-radius: 8px;
            border: 1px solid var(--border);
            margin: 0;
        }
        .triad-catalog {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        .triad-summary {
            display: flex;
            justify-content: space-between;
            font-size: 0.8125rem;
            color: var(--text-secondary);
        }
        .edge-chip {
            display: inline-block;
            padding: 4px 10px;
            margin: 2px;
            border-radius: 12px;
            font-size: 0.72rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.04em;
        }
        .edge-chip[data-color="Red"] { background: rgba(197, 132, 124, 0.25); color: #f0c7be; }
        .edge-chip[data-color="Green"] { background: rgba(107, 166, 138, 0.2); color: #cfe5d8; }
        .edge-chip[data-color="Yellow"] { background: rgba(212, 178, 106, 0.2); color: #f5e6c8; }
        .edge-chip[data-color="Blank"] { background: rgba(122, 128, 146, 0.2); color: #cbd1de; }
        .focus-detail {
            font-size: 0.875rem;
        }
        .focus-title {
            display: inline-block;
            padding: 6px 12px;
            border-radius: 6px;
            background: rgba(107, 137, 198, 0.2);
            color: #c3d4ff;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            margin-bottom: 8px;
        }
        .focus-description {
            color: var(--text-secondary);
            font-size: 0.8125rem;
            margin-bottom: 12px;
        }
        .spot-checks {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        .spot-check {
            display: flex;
            gap: 12px;
            padding: 12px;
            border-radius: 10px;
            border: 1px solid var(--border);
            background: rgba(6, 8, 14, 0.65);
            align-items: center;
        }
        .spot-check.pass {
            border-color: rgba(107, 166, 138, 0.6);
            background: rgba(107, 166, 138, 0.12);
        }
        .spot-check.fail {
            border-color: rgba(197, 132, 124, 0.7);
            background: rgba(197, 132, 124, 0.12);
        }
        .spot-check.current {
            border-color: rgba(107, 137, 198, 0.7);
            background: linear-gradient(135deg, rgba(18, 24, 38, 0.92), rgba(44, 60, 92, 0.65));
            box-shadow: 0 12px 24px rgba(4, 7, 13, 0.55);
        }
        .spot-check-status {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 1rem;
            color: #04070d;
            background: rgba(107, 137, 198, 0.2);
            flex-shrink: 0;
        }
        .spot-check.pass .spot-check-status {
            background: rgba(107, 166, 138, 0.85);
            color: #0b2a1f;
        }
        .spot-check.fail .spot-check-status {
            background: rgba(197, 132, 124, 0.85);
            color: #3d1d1a;
        }
        .spot-check.current .spot-check-status {
            background: rgba(107, 137, 198, 0.95);
            color: #030712;
        }
        .spot-check-body {
            flex: 1;
        }
        .spot-check-current-label {
            font-size: 0.72rem;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            color: #dce6ff;
            margin-bottom: 4px;
        }
        .spot-check-title {
            font-size: 0.85rem;
            font-weight: 600;
            margin-bottom: 4px;
        }
        .spot-check-rows {
            font-family: "IBM Plex Mono", monospace;
            font-size: 0.75rem;
            color: var(--text-secondary);
        }
        .spot-check-rows span {
            margin-right: 4px;
        }
        .spot-check-signature {
            margin-top: 4px;
            font-size: 0.75rem;
            color: var(--text-secondary);
        }
        .muted {
            color: var(--text-secondary);
            font-size: 0.85rem;
        }
        @media (max-width: 1400px) {
            .container {
                grid-template-columns: 1fr 380px;
            }
        }
        @media (max-width: 1024px) {
            .container {
                grid-template-columns: 1fr;
                grid-template-rows: auto;
            }
            .sidebar {
                max-height: none;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>Zero-Knowledge Graph Coloring Protocol</h1>
            <span class="status-badge" id="round-status">Initializing</span>
        </header>
        
        <main class="main-content">
            <div class="graph-container">
                <canvas id="graph-canvas" width="800" height="800"></canvas>
                <div class="graph-caption" id="canvas-caption">Graph visualization loading...</div>
            </div>
        </main>
        
        <aside class="sidebar">
            <div class="card">
                <h2 class="card-title">Protocol Steps</h2>
                <div id="protocol-steps" class="protocol-steps"></div>
            </div>
            
            <div class="card">
                <h2 class="card-title">Graph Information</h2>
                <div id="graph-details" class="info-grid"></div>
            </div>

            <div class="card">
                <h2 class="card-title">Permissible Triads C&prime;</h2>
                <div id="triad-catalog" class="triad-catalog">
                    <div class="muted">Loading C&prime; summary...</div>
                </div>
                <p class="muted" style="margin-top: 6px;">
                    The full catalog of admissible 3-node patterns now lives on its own page.
                </p>
                <a class="link-button" href="/triads">Open C&prime; Catalog</a>
            </div>
            
            <div class="card">
                <h2 class="card-title">Commitments</h2>
                <div id="commitment-details" class="info-grid"></div>
            </div>
            
            <div class="card">
                <h2 class="card-title">Challenge Details</h2>
                <div id="focus-detail" class="focus-detail">Waiting for challenge...</div>
            </div>

            <div class="card">
                <h2 class="card-title">Spot Checks vs C&prime;</h2>
                <div id="spot-checks" class="spot-checks">
                    <div class="muted">Awaiting spot challenge...</div>
                </div>
            </div>
            
            <div class="card">
                <h2 class="card-title">Merkle Explorer</h2>
                <p class="muted" style="margin-bottom: 12px;">
                    The leaf and chunk traversal controls now live on their own focused page for easier reading.
                </p>
                <a class="link-button" href="/merkle">Open Merkle View</a>
            </div>
            
            <div class="card">
                <h2 class="card-title">Protocol Animation Controls</h2>
                <div class="control-bar">
                    <button id="play-protocol">▶ Play Protocol</button>
                    <button id="pause-protocol">⏸ Pause</button>
                    <button id="step-protocol">⏭ Step</button>
                    <button id="reset-protocol">↺ Reset</button>
                </div>
                <div style="margin-top: 12px; font-size: 0.875rem; color: var(--text-secondary);">
                    <div>Current Step: <span id="current-step-display">1</span></div>
                    <div>Mode: <span id="protocol-mode">Auto</span></div>
                </div>
            </div>
            
            <div class="card">
                <h2 class="card-title">Activity Log</h2>
                <div class="logs-container">
                    <pre id="log-feed" class="logs">Waiting for protocol activity...</pre>
                </div>
            </div>
        </aside>
    </div>

    <script>
        const canvas = document.getElementById('graph-canvas');
        const ctx = canvas.getContext('2d');
        
        const palette = {
            Red: '#c57b74',
            Green: '#6ba68a',
            Yellow: '#d4b26a',
            Blank: '#7a8194',
        };
        const edgePalette = {
            Red: '#f5b1aa',
            Green: '#ade4c4',
            Yellow: '#fde6b4',
            Blank: '#cfd7ef',
        };
        const arrowPalette = {
            Red: '#d68279',
            Green: '#82c7a3',
            Yellow: '#dfc072',
            Blank: '#9aa4c7',
        };
        
        const state = {
            latestSnapshot: null,
            protocolStepState: {
                currentStep: 0,
                isPlaying: false,
                animationId: null,
                stepHistory: [],
            },
            highlightedSpotKey: null,
        };
        
        function resizeCanvases() {
            const graphContainer = canvas.parentElement;
            canvas.width = graphContainer.offsetWidth;
            canvas.height = Math.min(canvas.width, 800);

        }
        
        function project(x, y) {
            const bounds = 2.4;
            const px = ((x + 1.2) / bounds) * canvas.width;
            const py = ((1.2 - y) / bounds) * canvas.height;
            return [px, py];
        }

        function drawArrowhead(ctx, from, to, color, alpha = 1, size = 10) {
            const angle = Math.atan2(to[1] - from[1], to[0] - from[0]);
            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(to[0], to[1]);
            ctx.lineTo(
                to[0] - size * Math.cos(angle - Math.PI / 7),
                to[1] - size * Math.sin(angle - Math.PI / 7)
            );
            ctx.lineTo(
                to[0] - size * Math.cos(angle + Math.PI / 7),
                to[1] - size * Math.sin(angle + Math.PI / 7)
            );
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }

        function drawSelfLoop(ctx, node, loopSeg, activeNodes) {
            const [nx, ny] = project(node.x, node.y);
            const angle = Math.atan2(node.y, node.x);
            const offset = Math.max(18, canvas.width * 0.022);
            const radius = Math.max(16, canvas.width * 0.018);
            const centerX = nx + Math.cos(angle) * offset;
            const centerY = ny + Math.sin(angle) * offset;
            const span = Math.PI * 1.1;
            const startAngle = angle - span / 2;
            const endAngle = angle + span / 2;
            const baseColor = edgePalette[loopSeg.color] || '#d7ddef';
            const alpha = activeNodes.has(loopSeg.node) ? 1 : 0.75;

            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.strokeStyle = baseColor;
            ctx.lineWidth = activeNodes.has(loopSeg.node) ? 3 : 2;
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, startAngle, endAngle);
            ctx.stroke();
            ctx.restore();

            const tailPoint = [
                centerX + radius * Math.cos(endAngle - 0.22),
                centerY + radius * Math.sin(endAngle - 0.22),
            ];
            const arrowTip = [
                centerX + radius * Math.cos(endAngle),
                centerY + radius * Math.sin(endAngle),
            ];
            drawArrowhead(ctx, tailPoint, arrowTip, baseColor, alpha, 8);
        }

        function formatRoundLabel(roundIndex) {
            if (typeof roundIndex !== 'number' || Number.isNaN(roundIndex)) {
                return null;
            }
            return `#${String(roundIndex + 1).padStart(2, '0')}`;
        }

        function spotKey(entry) {
            if (!entry) {
                return null;
            }
            const nodes = Array.isArray(entry.nodes) ? entry.nodes.join('-') : '';
            return `${entry.round_label || '??'}:${nodes}:${entry.signature || ''}`;
        }

        function getActiveSpot(snapshot) {
            if (!snapshot) {
                return null;
            }
            const entries = snapshot.spot_checks || [];
            if (!entries.length) {
                return null;
            }

            if (state.highlightedSpotKey) {
                const match = entries.find(entry => spotKey(entry) === state.highlightedSpotKey);
                if (match) {
                    return match;
                }
                state.highlightedSpotKey = null;
            }

            const focusHasTriads = Array.isArray(snapshot.focus?.triads)
                && snapshot.focus.triads.length > 0;
            if (!focusHasTriads) {
                return null;
            }

            const roundLabel = formatRoundLabel(snapshot.round?.round);
            if (roundLabel) {
                const currentRoundEntry = entries.find(entry => entry.round_label === roundLabel);
                if (currentRoundEntry) {
                    return currentRoundEntry;
                }
            }

            return entries[0];
        }
        
        function getProtocolStep() {
            const snapshot = state.latestSnapshot;
            if (!snapshot) {
                // Initialize to step 1 if no snapshot
                if (state.protocolStepState.currentStep === 0) {
                    state.protocolStepState.currentStep = 1;
                }
                return state.protocolStepState.currentStep;
            }
            
            const round = snapshot.round || {};
            const commitments = snapshot.commitments;
            const focus = snapshot.focus;
            
            // If manual control is active (paused or step mode), use that
            if (!state.protocolStepState.isPlaying && state.protocolStepState.currentStep > 0) {
                return state.protocolStepState.currentStep;
            }
            
            // Auto mode: determine from snapshot
            let autoStep = 0;
            if (!commitments && round.round === null) {
                autoStep = 1;
            } else if (round.round !== null && !focus) {
                autoStep = 2;
            } else if (focus && round.status !== 'verified') {
                autoStep = 3;
            } else if (round.status === 'verified') {
                autoStep = 4;
            }
            
            // Update current step in auto mode
            if (state.protocolStepState.isPlaying && autoStep > 0) {
                state.protocolStepState.currentStep = autoStep;
            } else if (state.protocolStepState.currentStep === 0) {
                state.protocolStepState.currentStep = autoStep || 1;
            }
            
            return state.protocolStepState.currentStep;
        }
        
        function drawGraph() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const snapshot = state.latestSnapshot;
            if (!snapshot?.graph?.layout?.nodes?.length) {
                document.getElementById('canvas-caption').textContent = 'Waiting for graph data...';
                return;
            }

            const layout = snapshot.graph.layout;
            const focus = snapshot.focus || null;
            const round = snapshot.round || {};

            const focusEdgeItems = focus?.edges || [];
            const focusEdges = new Set(focusEdgeItems.map(e => `${e.from}-${e.to}`));
            const focusNodes = new Set();
            (focus?.triads || []).forEach(triad => triad.forEach(idx => focusNodes.add(idx)));

            const nodeLookup = new Map();
            layout.nodes.forEach(node => {
                nodeLookup.set(node.idx, node);
            });

            const activeSpot = getActiveSpot(snapshot);
            const activeNodes = new Set(activeSpot?.nodes || []);
            const activeEdgeItems = activeSpot?.edges && activeSpot.edges.length
                ? activeSpot.edges
                : focusEdgeItems;
            const activeEdges = new Set(activeEdgeItems.map(edge => `${edge.from}-${edge.to}`));
            const activeTriadKey = activeSpot
                ? [...activeSpot.nodes].sort((a, b) => a - b).join('-')
                : null;

            const currentRoundNumber = typeof round.round === 'number' ? Number(round.round) + 1 : 1;
            const roundLabelText = formatRoundLabel(round.round) || `#${String(currentRoundNumber).padStart(2, '0')}`;
            const revealedEdges = focus?.edges?.length || 0;
            const stepMap = {
                1: {
                    text: 'Step 1: Prover commits to permuted graph\nMerkle roots prepared for edges, permutation, and blank mask',
                    color: '#6b89c6',
                },
                2: {
                    text: `Step 2: Verifier issues challenge\nRound ${currentRoundNumber} – ${round.phase || 'challenge'}`,
                    color: '#d4b26a',
                },
                3: {
                    text: `Step 3: Prover opens requested data\n${revealedEdges} edges revealed with Merkle proofs`,
                    color: '#6ba68a',
                },
                4: {
                    text: 'Step 4: Verifier checks openings\nAll commitments confirmed for this round',
                    color: '#6ba68a',
                },
            };
            const currentStep = getProtocolStep();
            const stepInfo = stepMap[currentStep] || { text: '', color: '#6b89c6' };

            if (stepInfo.text) {
                ctx.save();
                ctx.globalAlpha = 0.08;
                ctx.fillStyle = stepInfo.color;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.restore();
            }

            layout.edges.forEach(edge => {
                const [x1, y1] = project(edge.x1, edge.y1);
                const [x2, y2] = project(edge.x2, edge.y2);
                const key = `${edge.from}-${edge.to}`;
                const isFocus = focusEdges.has(key);
                const isActive = activeEdges.has(key);
                const baseColor = edgePalette[edge.color] || '#d4d9ea';
                const arrowColor = isActive ? '#fef08a' : (arrowPalette[edge.color] || '#a7b2d4');
                const alpha = isActive ? 1 : isFocus ? 0.82 : 0.38;

                ctx.save();
                if (isActive) {
                    ctx.shadowColor = '#fcd34d';
                    ctx.shadowBlur = 22;
                }
                ctx.globalAlpha = alpha;
                ctx.lineWidth = isActive ? 4 : isFocus ? 2.2 : 1.2;
                ctx.strokeStyle = isActive ? '#fef08a' : baseColor;
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
                ctx.restore();

                const arrowFrom = [
                    x1 + (x2 - x1) * 0.78,
                    y1 + (y2 - y1) * 0.78,
                ];
                const arrowTo = [
                    x1 + (x2 - x1) * 0.94,
                    y1 + (y2 - y1) * 0.94,
                ];
                drawArrowhead(ctx, arrowFrom, arrowTo, arrowColor, alpha, isActive ? 12 : 9);
            });

            if (activeEdgeItems.length) {
                activeEdgeItems.forEach(edge => {
                    const key = `${edge.from}-${edge.to}`;
                    const fromNode = nodeLookup.get(edge.from);
                    const toNode = nodeLookup.get(edge.to);
                    if (!fromNode || !toNode) {
                        return;
                    }
                    const [x1, y1] = project(fromNode.x, fromNode.y);
                    const [x2, y2] = project(toNode.x, toNode.y);
                    const isActive = activeEdges.has(key);
                    const baseColor = edgePalette[edge.color] || '#dbe0f0';
                    const arrowColor = isActive ? '#fef08a' : (arrowPalette[edge.color] || '#a7b2d4');
                    const alpha = isActive ? 1 : 0.9;
                    ctx.save();
                    ctx.shadowColor = isActive ? '#fcd34d' : '#b4c6fc';
                    ctx.shadowBlur = isActive ? 26 : 10;
                    ctx.globalAlpha = alpha;
                    ctx.lineWidth = isActive ? 4.2 : 2.6;
                    ctx.strokeStyle = isActive ? '#fef08a' : baseColor;
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                    ctx.restore();

                    const arrowFrom = [
                        x1 + (x2 - x1) * 0.8,
                        y1 + (y2 - y1) * 0.8,
                    ];
                    const arrowTo = [
                        x1 + (x2 - x1) * 0.96,
                        y1 + (y2 - y1) * 0.96,
                    ];
                    drawArrowhead(ctx, arrowFrom, arrowTo, arrowColor, alpha, isActive ? 13 : 9);
                });
            }

            if (Array.isArray(layout.loops) && layout.loops.length) {
                layout.loops.forEach(loopSeg => {
                    const node = nodeLookup.get(loopSeg.node);
                    if (!node) {
                        return;
                    }
                    drawSelfLoop(ctx, node, loopSeg, activeNodes);
                });
            }

            layout.nodes.forEach(node => {
                const [x, y] = project(node.x, node.y);
                const isFocus = focusNodes.has(node.idx);
                const isActive = activeNodes.has(node.idx);
                const radius = isActive ? 16 : isFocus ? 13 : 9;
                const nodeColor = isActive ? '#fdf18f' : isFocus ? stepInfo.color : '#c7d0e2';

                ctx.save();
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fillStyle = '#05070d';
                ctx.fill();
                if (isActive) {
                    ctx.shadowColor = '#fcd34d';
                    ctx.shadowBlur = 30;
                }
                ctx.strokeStyle = nodeColor;
                ctx.lineWidth = isActive ? 3.6 : isFocus ? 2.2 : 1.2;
                ctx.globalAlpha = isActive ? 1 : isFocus ? 0.95 : 0.9;
                ctx.stroke();

                ctx.fillStyle = '#e3e8f4';
                ctx.font = `600 ${isActive ? 17 : isFocus ? 15 : 11}px "Space Grotesk", sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.globalAlpha = 1;
                ctx.fillText(node.idx, x, y);
                ctx.restore();
            });

            if (focus && (focus.triads || []).length) {
                (focus.triads || []).forEach(triad => {
                    if (triad.length !== 3) return;
                    const nodes = triad
                        .map(idx => nodeLookup.get(idx))
                        .filter(Boolean);
                    if (nodes.length !== 3) return;
                    const triadKey = [...triad].sort((a, b) => a - b).join('-');
                    const isActiveTriad = activeTriadKey && triadKey === activeTriadKey;

                    ctx.save();
                    ctx.setLineDash(isActiveTriad ? [10, 4] : [6, 4]);
                    ctx.globalAlpha = isActiveTriad ? 0.55 : 0.25;
                    ctx.strokeStyle = isActiveTriad ? '#f8e45c' : stepInfo.color;
                    ctx.lineWidth = isActiveTriad ? 3 : 2;
                    ctx.beginPath();
                    const [startX, startY] = project(nodes[0].x, nodes[0].y);
                    ctx.moveTo(startX, startY);
                    nodes.slice(1).forEach(node => {
                        const [nx, ny] = project(node.x, node.y);
                        ctx.lineTo(nx, ny);
                    });
                    ctx.closePath();
                    ctx.stroke();
                    ctx.globalAlpha = isActiveTriad ? 0.2 : 0.08;
                    ctx.fillStyle = isActiveTriad ? 'rgba(248, 228, 92, 0.35)' : stepInfo.color;
                    ctx.fill();
                    ctx.setLineDash([]);
                    ctx.restore();
                });
            }

            if (activeSpot) {
                ctx.save();
                const boxWidth = 320;
                const boxHeight = 96;
                const boxX = canvas.width - boxWidth - 22;
                const boxY = canvas.height - boxHeight - 22;
                ctx.globalAlpha = 0.95;
                ctx.fillStyle = 'rgba(5, 7, 13, 0.9)';
                ctx.beginPath();
                ctx.roundRect(boxX, boxY, boxWidth, boxHeight, 12);
                ctx.fill();
                ctx.strokeStyle = '#f8e45c';
                ctx.lineWidth = 1.2;
                ctx.stroke();

                ctx.fillStyle = '#fef3c7';
                ctx.font = '600 14px "Space Grotesk", sans-serif';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';
                ctx.fillText(`Spot ${activeSpot.round_label} · Nodes [${activeSpot.nodes.join(', ')}]`, boxX + 16, boxY + 16);

                ctx.fillStyle = '#cbd5f5';
                ctx.font = '12px "IBM Plex Mono", monospace';
                const rowText = (activeSpot.rows || []).join('   ');
                ctx.fillText(rowText, boxX + 16, boxY + 40);
                const signature = activeSpot.signature ? `Signature ${activeSpot.signature}` : '';
                if (signature) {
                    ctx.fillText(signature, boxX + 16, boxY + 60);
                }
                ctx.restore();
            }

            if (stepInfo.text) {
                ctx.save();
                const boxWidth = 340;
                const boxHeight = 76;
                const boxX = 18;
                const boxY = 18;
                ctx.globalAlpha = 0.92;
                ctx.fillStyle = 'rgba(5, 7, 13, 0.78)';
                ctx.beginPath();
                ctx.roundRect(boxX, boxY, boxWidth, boxHeight, 12);
                ctx.fill();
                ctx.strokeStyle = stepInfo.color;
                ctx.lineWidth = 1;
                ctx.stroke();

                ctx.fillStyle = '#f8fafc';
                ctx.font = '600 14px "Space Grotesk", sans-serif';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';
                const lines = stepInfo.text.split('\n');
                const lineHeight = 18;
                lines.forEach((line, idx) => {
                    ctx.fillText(line, boxX + 16, boxY + 14 + idx * lineHeight);
                });
                ctx.restore();
            }

            const captionEl = document.getElementById('canvas-caption');
            if (activeSpot) {
                captionEl.textContent = `Round ${roundLabelText}: verifying spot [${activeSpot.nodes.join(', ')}]`;
            } else if (focus?.triads?.length) {
                captionEl.textContent = `Showing ${layout.visualized} nodes · ${focus.triads.length} triads under inspection`;
            } else {
                captionEl.textContent = `Showing ${layout.visualized} nodes`;
            }
        }
        
        function renderGraphInfo(snapshot) {
            const g = snapshot.graph;
            const container = document.getElementById('graph-details');
            container.innerHTML = `
                <div class="info-item">
                    <span class="info-label">Nodes</span>
                    <span class="info-value">${g.nodes}</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Blank Edges</span>
                    <span class="info-value">${g.blank_edges}/${g.blank_limit}</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Triads |C|</span>
                    <span class="info-value">${g.color_set_size.toLocaleString()}</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Samples</span>
                    <span class="info-value">${g.sample_edges.length}</span>
                </div>
            `;
        }

        function renderTriadCatalog(snapshot) {
            const catalog = snapshot.triads;
            const container = document.getElementById('triad-catalog');
            if (!catalog || !catalog.patterns || catalog.patterns.length === 0) {
                container.innerHTML = '<div class="muted">Triad catalog unavailable.</div>';
                return;
            }
            const preview = catalog.patterns.slice(0, 3).map(pattern => {
                const label = pattern.id.toString().padStart(2, '0');
                return `#${label}:${pattern.signature}`;
            }).join('  ·  ');

            container.innerHTML = `
                <div class="triad-summary">
                    <span>|C&prime;| = ${catalog.total.toLocaleString()}</span>
                    <span>${catalog.patterns.length} canonical patterns</span>
                </div>
                <div class="muted">Preview: ${preview || 'unavailable'} · visit the catalog for the full set.</div>
            `;
        }
        
        function renderCommitments(snapshot) {
            const container = document.getElementById('commitment-details');
            if (!snapshot.commitments) {
                container.innerHTML = '<div style="color: var(--text-secondary);">Pending...</div>';
                return;
            }
            
            const c = snapshot.commitments;
            const shortHash = (h) => h ? `${h.slice(0, 8)}...${h.slice(-6)}` : 'pending';
            
            container.innerHTML = `
                <div class="info-item">
                    <span class="info-label">Graph Root</span>
                    <span class="info-value" style="font-size: 0.75rem;">${shortHash(c.graph_root)}</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Perm Root</span>
                    <span class="info-value" style="font-size: 0.75rem;">${shortHash(c.perm_root)}</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Blank Root</span>
                    <span class="info-value" style="font-size: 0.75rem;">${shortHash(c.blank_root)}</span>
                </div>
            `;
        }
        
        function renderFocus(snapshot) {
            const container = document.getElementById('focus-detail');
            const focus = snapshot.focus;
            
            if (!focus) {
                container.innerHTML = '<div style="color: var(--text-secondary);">Waiting for challenge...</div>';
                return;
            }
            
            const triads = focus.triads.map(t => `<span class="triad">[${t.join(', ')}]</span>`).join('');
            const edges = focus.edges.map(e => `<span class="edge-chip" data-color="${e.color}">${e.from}→${e.to}</span>`).join('');
            
            container.innerHTML = `
                <div class="focus-title">${focus.title}</div>
                <div class="focus-description">${focus.description}</div>
                ${triads ? `<div style="margin-top: 8px;">${triads}</div>` : ''}
                ${edges ? `<div style="margin-top: 8px;">${edges}</div>` : ''}
            `;
        }

        function renderSpotChecks(snapshot) {
            const container = document.getElementById('spot-checks');
            const entries = snapshot.spot_checks || [];
            if (!entries.length) {
                state.highlightedSpotKey = null;
                container.innerHTML = '<div class="muted">No spot checks yet.</div>';
                return;
            }

            const activeSpot = getActiveSpot(snapshot);
            const activeKey = spotKey(activeSpot);

            container.innerHTML = entries
                .map(entry => {
                    const rows = (entry.rows || [])
                        .map(row => `<span>${row.replace(/ /g, '&nbsp;')}</span>`)
                        .join('<span>|</span>');
                    const statusLabel = entry.in_set ? 'Matches C&prime;' : 'Rejected by C&prime;';
                    const entryKey = spotKey(entry);
                    const encodedKey = encodeURIComponent(entryKey || '');
                    const isCurrent = activeKey && entryKey === activeKey;
                    const classes = ['spot-check', entry.in_set ? 'pass' : 'fail'];
                    if (isCurrent) {
                        classes.push('current');
                    }
                    const labelPrefix = state.highlightedSpotKey ? 'Selected spot' : 'Live spot';
                    const activeLabel = isCurrent
                        ? `<div class="spot-check-current-label">${labelPrefix} · ${entry.round_label}</div>`
                        : '';
                    return `
                        <div class="${classes.join(' ')}" data-spot-key="${encodedKey}">
                            <div class="spot-check-status">${entry.in_set ? '✓' : '✗'}</div>
                            <div class="spot-check-body">
                                ${activeLabel}
                                <div class="spot-check-title">${entry.round_label} · [${entry.nodes.join(', ')}]</div>
                                <div class="spot-check-rows">${rows}</div>
                                <div class="spot-check-signature">${statusLabel} · ${entry.signature}</div>
                            </div>
                        </div>
                    `;
                })
                .join('');
        }
        
        function updateProtocolSteps(snapshot) {
            const container = document.getElementById('protocol-steps');
            const round = snapshot.round || {};
            const commitments = snapshot.commitments;
            const focus = snapshot.focus;
            
            const steps = [
                {
                    icon: '1',
                    title: 'Commit',
                    detail: commitments ? 'Roots committed' : 'Preparing...',
                    active: !commitments && round.round === null,
                    completed: !!commitments,
                },
                {
                    icon: '2',
                    title: 'Challenge',
                    detail: round.round !== null ? `Round ${Number(round.round) + 1}: ${round.phase}` : 'Waiting...',
                    active: round.round !== null && !focus,
                    completed: !!focus,
                },
                {
                    icon: '3',
                    title: 'Response',
                    detail: focus ? focus.title : 'Waiting...',
                    active: !!focus && round.status !== 'verified',
                    completed: !!focus && round.status === 'verified',
                },
                {
                    icon: '4',
                    title: 'Verify',
                    detail: round.status || 'Pending...',
                    active: round.status === 'verified',
                    completed: round.status === 'verified',
                },
            ];
            
            container.innerHTML = steps.map((step, idx) => {
                const classes = ['protocol-step'];
                if (step.active) classes.push('active');
                if (step.completed && !step.active) classes.push('completed');
                
                return `
                    <div class="${classes.join(' ')}">
                        <div class="step-icon">${step.icon}</div>
                        <div class="step-content">
                            <div class="step-title">${step.title}</div>
                            <div class="step-detail">${step.detail}</div>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        function renderLogs(snapshot) {
            const logFeed = document.getElementById('log-feed');
            const logs = snapshot.logs || [];
            const logText = logs.length > 0 
                ? logs.slice().reverse().map(entry => `• ${entry}`).join('\n')
                : 'Waiting for protocol activity...';
            
            // Only update if content changed to prevent flashing
            if (logFeed.textContent !== logText) {
                logFeed.textContent = logText;
            }
        }
        
        function renderSnapshot(snapshot) {
            state.latestSnapshot = snapshot;
            renderGraphInfo(snapshot);
            renderTriadCatalog(snapshot);
            renderCommitments(snapshot);
            renderFocus(snapshot);
            renderSpotChecks(snapshot);
            updateProtocolSteps(snapshot);
            renderLogs(snapshot);
            
            const round = snapshot.round || {};
            const statusEl = document.getElementById('round-status');
            if (round.round !== null) {
                statusEl.textContent = `Round ${Number(round.round) + 1}: ${round.phase || 'active'}`;
                if (round.status) statusEl.textContent += ` - ${round.status}`;
            } else {
                statusEl.textContent = 'Initializing';
            }
        }
        
        
        function animateProtocolStep() {
            if (!state.latestSnapshot) return;
            
            const maxStep = 4;
            if (state.protocolStepState.currentStep < maxStep) {
                state.protocolStepState.currentStep++;
                updateProtocolStepDisplay();
            } else {
                // Loop back to step 1
                state.protocolStepState.currentStep = 1;
                updateProtocolStepDisplay();
            }
        }
        
        function updateProtocolStepDisplay() {
            const display = document.getElementById('current-step-display');
            if (display) {
                display.textContent = state.protocolStepState.currentStep || getProtocolStep();
            }
        }
        
        function setupControls() {
            // Protocol step controls
            document.getElementById('play-protocol').addEventListener('click', function() {
                if (state.protocolStepState.isPlaying) {
                    state.protocolStepState.isPlaying = false;
                    if (state.protocolStepState.animationId) {
                        clearInterval(state.protocolStepState.animationId);
                        state.protocolStepState.animationId = null;
                    }
                    this.textContent = '▶ Play Protocol';
                    document.getElementById('protocol-mode').textContent = 'Manual';
                } else {
                    state.protocolStepState.isPlaying = true;
                    this.textContent = '⏸ Pause';
                    document.getElementById('protocol-mode').textContent = 'Auto';
                    state.protocolStepState.animationId = setInterval(() => {
                        animateProtocolStep();
                    }, 2000); // Change step every 2 seconds
                }
            });
            
            document.getElementById('pause-protocol').addEventListener('click', () => {
                state.protocolStepState.isPlaying = false;
                if (state.protocolStepState.animationId) {
                    clearInterval(state.protocolStepState.animationId);
                    state.protocolStepState.animationId = null;
                }
                document.getElementById('play-protocol').textContent = '▶ Play Protocol';
                document.getElementById('protocol-mode').textContent = 'Manual';
            });
            
            document.getElementById('step-protocol').addEventListener('click', () => {
                state.protocolStepState.isPlaying = false;
                if (state.protocolStepState.animationId) {
                    clearInterval(state.protocolStepState.animationId);
                    state.protocolStepState.animationId = null;
                }
                document.getElementById('play-protocol').textContent = '▶ Play Protocol';
                document.getElementById('protocol-mode').textContent = 'Manual';
                animateProtocolStep();
            });
            
            document.getElementById('reset-protocol').addEventListener('click', () => {
                state.protocolStepState.currentStep = 1;
                state.protocolStepState.isPlaying = false;
                if (state.protocolStepState.animationId) {
                    clearInterval(state.protocolStepState.animationId);
                    state.protocolStepState.animationId = null;
                }
                document.getElementById('play-protocol').textContent = '▶ Play Protocol';
                document.getElementById('protocol-mode').textContent = 'Manual';
                updateProtocolStepDisplay();
            });
        }

        function setupSpotCheckHover() {
            const container = document.getElementById('spot-checks');
            if (!container) {
                return;
            }

            container.addEventListener('mouseover', event => {
                const origin = event.target instanceof Element ? event.target : null;
                const card = origin?.closest('.spot-check');
                if (!card) {
                    return;
                }
                const keyAttr = card.getAttribute('data-spot-key');
                const decodedKey = keyAttr ? decodeURIComponent(keyAttr) : null;
                if (decodedKey && state.highlightedSpotKey !== decodedKey) {
                    state.highlightedSpotKey = decodedKey;
                    if (state.latestSnapshot) {
                        renderSpotChecks(state.latestSnapshot);
                    }
                }
            });

            container.addEventListener('mouseleave', event => {
                if (container.contains(event.relatedTarget)) {
                    return;
                }
                if (state.highlightedSpotKey !== null) {
                    state.highlightedSpotKey = null;
                    if (state.latestSnapshot) {
                        renderSpotChecks(state.latestSnapshot);
                    }
                }
            });
        }
        
         // Add roundRect polyfill for older browsers
         if (!CanvasRenderingContext2D.prototype.roundRect) {
             CanvasRenderingContext2D.prototype.roundRect = function(x, y, width, height, radius) {
                 this.beginPath();
                 this.moveTo(x + radius, y);
                 this.lineTo(x + width - radius, y);
                 this.quadraticCurveTo(x + width, y, x + width, y + radius);
                 this.lineTo(x + width, y + height - radius);
                 this.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                 this.lineTo(x + radius, y + height);
                 this.quadraticCurveTo(x, y + height, x, y + height - radius);
                 this.lineTo(x, y + radius);
                 this.quadraticCurveTo(x, y, x + radius, y);
                 this.closePath();
             };
         }
         
         async function refresh() {
             try {
                 const response = await fetch('/snapshot');
                 if (!response.ok) throw new Error('Bad response');
                 const snapshot = await response.json();
                 renderSnapshot(snapshot);
             } catch (err) {
                 console.warn('Refresh error:', err);
             }
         }
         
         function animationLoop() {
             drawGraph();
             requestAnimationFrame(animationLoop);
         }
        
        resizeCanvases();
        setupControls();
        setupSpotCheckHover();
        updateProtocolStepDisplay();
        refresh();
        setInterval(refresh, 500);
        requestAnimationFrame(animationLoop);
        
        window.addEventListener('resize', () => {
            resizeCanvases();
        });
    </script>
</body>
</html>
